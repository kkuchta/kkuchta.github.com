<!DOCTYPE html>
<html>
  <head>
    <title>Kevin Kuchta</title>
    <link href='/stylesheets/global.css' rel='stylesheet' type='text/css' />
<link href='http://fonts.googleapis.com/css?family=Bevan' rel='stylesheet' type='text/css' />
<link href='http://fonts.googleapis.com/css?family=PT+Sans' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  //<![CDATA[
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-27863897-1']);
    _gaq.push(['_setDomainName', 'kevinkuchta.com']);
    _gaq.push(['_trackPageview']);
    
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  //]]>
</script>

  </head>
  <body>
    <div class='container-fluid'>
      <div class='row-fluid'>
        <div class='span4 sidebar'>
          <h1>
  <a href='/'>Kevin<br>Kuchta</a>
</h1>
<ul class='unstyled'>
  <li>
    <a href='/projects'>Projects</a>
  </li>
  <li>
    <a href='/hacks'>Hacks</a>
  </li>
  <li>
    <a href='/talks'>Talks</a>
  </li>
  <li>
    <a href='/contact'>On the web</a>
  </li>
  <li>
    <a href='/resume'>Resume</a>
  </li>
</ul>

        </div>
        <div class='span7 main'>
          <h1 class='title'>Catcher's Mitt- A Simple Tool To Print Http Requests</h1>
<p>The other day I released <a href="https://github.com/kkuchta/mitt">Mitt</a>, a simple tool that listens for http connections on a specified port and prints out requests to stdout.</p>

<!--break-->


<p>There are other ways to accomplish thisâ€“ hell, a <a href="https://gist.github.com/kkuchta/f3b78f3c490fb132ee2eac245d4fd04a">10-line rackup file</a> will do the same thing.  But if <em>I</em> had this need, I'll bet at least a few other people do too.  To that end, I expanded that rackup script into a ruby gem and published it (with a bit of cleanup and a few more options).</p>

<p>Honestly, I'm a bit surprised this tool didn't exist already.  I keep expecting someone to tell me "Oh yeah, you can do that by just piping <code>foo</code> through <code>xargs</code> and <code>netcat</code>".  I haven't found a tool like this yet, though, so maybe I really am the first to package it up like this.</p>

<p>The use case for me, at least, has been testing out infrastructure stuff.  I was messing around with the <a href="https://www.elastic.co/webinars/introduction-elk-stack">elk stack</a> last month at work and I regularly found myself trying to determine whether requests were making it between servers (and containers) or not.  By telling some service to point to my laptop running something like Mitt instead of logstash, I could tell whether the log lines were actually getting sent (we were sending over https instead of with syslog for reasons not worth getting into).</p>

<p>Then later that month I found myself working on a slack bot that wasn't handling a webhook properly.  Since the webhook request was coming through an ssh tunnel to my laptop, the issue could have been a problem with my slack configuration, a problem with the tunnel, or a problem with my code.  Running mitt let me eliminate the first two options by confirming that requests <em>were</em> making it to my laptop.</p>

<p>So- it's a bit of a niche tool, but it's dead simple.  <code>mitt 8080</code> listens on port 8080.  <code>mitt 8080 foobar</code> listens on port 8080 and returns <code>foobar</code> in the response body to all http requests (if your requester expects a specific body for some reason).  I'm hoping it's so simple that no documentation is necessary (although there is some anyway).</p>

<p>Here's hoping that this little tool is useful to someone else besides me, although I had fun writing it regardless.</p>


        </div>
      </div>
    </div>
  </body>
</html>
