---
layout: post
title: How to use time
---
There are two main models for measuring work:

1. Work as long or as short as you have to, so long as you get your work done.
- Reward people that get their work done fast
- Punish people that get their work done slow
- Fire those that don't finish it

Pros:
- Has an innate appeal to developers
- Incentivizes smart working over hard working
- Can more easily accomodate a mix of developer skills: good devs work fast, mediocre devs just work longer, and you get the same amount of productivity from each

Cons:
<!--- Assumes that "your work" is well chosen (can be extremely arbitrary)-->
- Relies on managers being able to correctly size what "your work" is.
- Perverse incentive to managers to just add more work
- Naturally leads to crunch time
  - Because you can never really predict exactly how long a given project will take, you'll end up with some crunch weeks and some light weeks.
  - Natural tendancy of managers to, when they see light weeks, increase work expectations
  - "Reward for finishing your work is more work"
  - Now the "light" weeks fill the entire week, and the normal + heavy weeks run over and take crunch time.

2. Work for a fixed period, and get as much done in that time as possible.
- Reward people who get a lot of work done per period
- Punish people who get little work done per period
- Fire people who get too little work done per period

Pros:
- Good for work-life balance
- Allows you to set clear expectations up-front as to the time comittment of
a job
- Fits better in companies where a dev's sphere of work might well be "everything", since there's always more work to do
- Works well with self-driven devs who are largely self-mananging, since it prevents overworking and, if you trust them to be productive, it allows for a more hands-off approach to running a dev team.

Cons:
- External deadlines may still mandate crunch time
- Relies on managers being able to accurately measure efficiency of a dev
- Doesn't automatically reward smart work- managers have to do that.
- Mediocre devs just get less work done overall than smart devs

Conclusion:

1 Works better for larger companies where the work is more consistant (and thus easier to predict).  Also good when you have a solid group of well-tested managers.

2 Works better for small companies where the work is changing rapidly (and thus hard to predect).  Also good for preventing overwork and burnout.  Good for managed long hours (eg, "we work 50 hours, no more, no less" vs "We work 40 hours, except when we work 70").  Also good for when you don't have many managers, and you trust your devs to be as productive as you can without someone looking over their shoulder.
